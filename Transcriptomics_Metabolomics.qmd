---
title: "Transcriptomics_Metabolomics"
author: "Estefania Espin"
format: html
editor: visual
---

## Transcriptomics and Metabolomics Analysis

### Transcriptomics

Importing datasets and metadata for gene expression analysis from NanoString, with expression values normalized to Positive CodeSets and housekeeping genes using NSolver.

```{r}
#| warning: false
library(tidyverse)
Subjects <- read.csv("SubjectsNoRep.csv")

FCdata <- read.csv("NormNoRepNoHK.csv")
head(FCdata)[1:5]

#Taking log2 of all data after normalization in NSolver
FCdata <- 
  FCdata %>%
  column_to_rownames("SampleID") %>% 
  log2() %>% 
  rownames_to_column("SampleID")
head(FCdata)[1:5]

#Linking data
linked_data <- left_join(Subjects, FCdata)
head(linked_data)[1:8]
```

Performing differential gene expression analysis using limma

```{r}
#| warning: false
#Differential Gene Expression with limma
library(limma)
library(edgeR)
library(ggrepel)

#select the counts data and convert it into correct format (based on subject ID)
linked_data <-
  linked_data %>%
  mutate_if(is.character,as.factor)
str(linked_data)

#creating counts_data with variables: SampleID and gene's counts
counts_data <- linked_data[,c(1,7:756)]

#transpose this data to create the counts data
counts_new <- data.frame(t(counts_data[-1]))
colnames(counts_new) <- counts_data[, 1]

#now get the column data
column_data <- linked_data[,c(1,6)]

#changing the order of the levels to have controls first and then cases
column_data$LCStatus <-  factor(column_data$LCStatus, levels =  c("Control", "Case"))
column_data$LCStatus

#check whether all column names in counts data also exist in rownames in column data
all(colnames(counts_new) %in% (column_data$SampleID))

#check whether the rows and columns are in the same order (i.e., the subject IDs)
all(colnames(counts_new) == column_data$SampleID)

#for limma, create a design matrix
design <- model.matrix(~LCStatus, data=column_data)

# Fit the linear model
fit <- lmFit(counts_new, design)
fit.limma <- eBayes(fit)

ResultsTopGenes <- topTable(fit.limma, n = Inf) %>% as.data.frame() %>% rownames_to_column("Gene")
head(ResultsTopGenes)

res <- ResultsTopGenes
```

Renaming genes that were incompatible with external databases

```{r}
#| warning: false
#Renaming gene names to be compatible with external databases
#BAGE gene not found
res$Gene[res$Gene == "HLA.B"] = "HLA-B"
res$Gene[res$Gene == "HLA.E"] = "HLA-E"
res$Gene[res$Gene == "CD97"] = "ADGRE5"
res$Gene[res$Gene == "KIR_Inhibiting_Subgroup_1"] = "KIR2DL1"
res$Gene[res$Gene == "KIR_Inhibiting_Subgroup_2"] = "KIR2DL3"
res$Gene[res$Gene == "KIR_Activating_Subgroup_1"] = "KIR3DS1"
res$Gene[res$Gene == "KIR_Activating_Subgroup_2"] = "KIR2DS1"
res$Gene[res$Gene == "HLA.A"] = "HLA-A"
res$Gene[res$Gene == "HLA.C"] = "HLA-C"
res$Gene[res$Gene == "HLA.G"] = "HLA-G"
res$Gene[res$Gene == "HLA.DOB"] = "HLA-DOB"
res$Gene[res$Gene == "HLA.DMB"] = "HLA-DMB"
res$Gene[res$Gene == "HLA.DRB1"] = "HLA-DRB1" 
res$Gene[res$Gene == "HLA.DRB4"] = "HLA-DRB4"
res$Gene[res$Gene == "HLA.DRA"] = "HLA-DRA"
res$Gene[res$Gene == "NOS2A"] = "NOS2"
res$Gene[res$Gene == "HLA.DRB3"] = "HLA-DRB3"
res$Gene[res$Gene == "HLA.DPB1"] = "HLA-DPB1"
res$Gene[res$Gene == "HLA.DQA1"] = "HLA-DQA1"
res$Gene[res$Gene == "HLA.DMA"] = "HLA-DMA"
res$Gene[res$Gene == "HLA.DPA1"] = "HLA-DPA1"
res$Gene[res$Gene == "HLA.DQB1"] = "HLA-DQB1"
res$Gene[res$Gene == "DDX58"] = "RIGI"
res$Gene[res$Gene == "CD3EAP"] = "POLR1G"
res$Gene[res$Gene == "AMICA1"] = "JAML"
res$Gene[res$Gene == "IL8"] = "CXCL8"

#Eliminating the viral genes, which did not have any signal
res <- res %>%
  filter(!Gene %in% c("CMV.UL83",
                      "EBV.LMP2",
                      "SARS.CoV.2_N",
                      "SARS.CoV.2_S",
                      "SARS.CoV.2_M"))
View(res)
str(res)
```

Selecting the genes that best discriminate Long COVID from control samples based on limma analysis

```{r}
#| warning: false
#Getting the most discriminating genes (LC vs control) according to limma
# Filter for significant genes with large fold change
top_sig_bio_genes <- res %>%
  filter(adj.P.Val < 0.10 & abs(logFC) > log2(1.5)) %>%
  arrange(adj.P.Val)

# View top hits
head(top_sig_bio_genes)
#"ANXA1", "RPS6", "ITGA2B", "CD163", "S100A8", "THBS1", "KIR2DL1", "LY96"

```

Performing PCA and PERMANOVA to analyze transcriptomic data

```{r}
#| warning: false
#Step 1: Extract significant DEGs
# Extract all DE results
results <- topTable(fit.limma, coef="LCStatusCase", number=Inf)

# Filter for significant DEGs (adjust as needed)
deg <- results %>%
  filter(adj.P.Val < 0.10)

# View top DEGs
head(deg)
str(deg)

#Step 2: Subset your expression matrix to only DEGs
# Get DEG gene names (they're rownames in 'results')
deg_genes <- rownames(deg)

# Subset expression data to just DEGs
deg_expr <- counts_new[deg_genes, ]

#Step 3: Transpose and perform PCA
# Transpose so rows = samples, columns = genes
deg_expr_t <- t(deg_expr)

# Perform PCA
pca <- prcomp(deg_expr_t, scale. = TRUE)

# Combine PCA results with sample metadata
pca_data <- as.data.frame(pca$x)
pca_data$SampleID <- rownames(pca_data)

# Merge with sample info
pca_data <- left_join(pca_data, column_data, by = "SampleID")

#PERMANOVA
library(vegan)

#Step-by-step: Go from your limma results to PERMANOVA + PCA plot

#1. Filter DEGs and prepare expression data (you’ve already done this):
# Keep DEGs with adjusted p-value < 0.10
deg <- results %>%
  filter(adj.P.Val < 0.10)

# Get gene names
deg_genes <- rownames(deg)

# Subset expression matrix to DEGs
deg_expr <- counts_new[deg_genes, ]

# Transpose to samples x genes
deg_expr_t <- t(deg_expr)

#2. Run PERMANOVA
library(vegan)

# Make sure grouping variable is a factor
column_data$LCStatus <- as.factor(column_data$LCStatus)

# PERMANOVA: test if expression profiles differ by LCStatus
permanova <- adonis2(deg_expr_t ~ LCStatus, data = column_data, method = "euclidean")

# Inspect result
print(permanova)

# Extract R² and p-value for annotation
r2 <- round(permanova$R2[1], 3)
pval <- permanova$`Pr(>F)`[1]

#PCA and top 10 loading vectors
pca_result <- prcomp(deg_expr_t, scale. = TRUE)

# Create PCA data frame
pca_data <- as.data.frame(pca_result$x)
pca_data$SampleID <- rownames(pca_data)
pca_data <- left_join(pca_data, column_data, by = "SampleID")

# Extract loadings (gene contributions)
loadings <- as.data.frame(pca_result$rotation[, 1:2])
loadings$Gene <- rownames(loadings)
loadings$Magnitude <- sqrt(loadings$PC1^2 + loadings$PC2^2)

# Top 10 loading genes
top_loadings <- loadings %>%
  dplyr::arrange(desc(Magnitude)) %>%
  dplyr::slice(1:10)
head(top_loadings)

#write.csv(top_loadings, "Discriminatory_Genes_PCA.csv", row.names = FALSE )

# Run PERMDISP (test homogeneity of group dispersions)
dist_matrix <- dist(deg_expr_t, method = "euclidean")  # distance matrix from DEG expression

dispersion <- betadisper(dist_matrix, column_data$LCStatus)  # group dispersions
anova_disp <- anova(dispersion)          # ANOVA test for dispersions
permutest_disp <- permutest(dispersion)  # permutation test for dispersions

# Print results
print(anova_disp)
print(permutest_disp)

# Optional: visualize dispersions
plot(dispersion)

# Extract stats for annotation
r2 <- round(permanova$R2[1], 3)
pval_permanova <- format.pval(permanova$`Pr(>F)`[1], digits = 3, eps = 0.001)
pval_permdisp <- format.pval(permutest_disp$tab[1, "Pr(>F)"], digits = 3, eps = 0.001)

 #PCA Plot with stats_star instead of ellipse
        library(ggpubr)
#Scaling the loadings
top_loadings_scaled <- top_loadings %>%
  mutate(
    PC1 = PC1 * 15,   # enlarge along PC1
    PC2 = PC2 * 15    # enlarge along PC2
  )
        
# Final PCA Plot with annotation using stat_stars()
        pca_gene <- ggplot(pca_data, aes(x = PC1, y = PC2, color = LCStatus)) +
          geom_point(size = 1, alpha = 0.8) +
          ggpubr::stat_stars(aes(group = LCStatus), linetype = 2, size = 1) +  # <-- replaced stat_ellipse
          
          # Loading vectors
          geom_segment(data = top_loadings_scaled,
                       aes(x = 0, y = 0, xend = PC1, yend = PC2),
                       arrow = arrow(length = unit(0.2, "cm")),
                       color = "gray50", fontface = "bold",  
                       inherit.aes = FALSE) +
          
          # Loading labels
          geom_label_repel(data = top_loadings_scaled,
                          aes(x = PC1, y = PC2, label = Gene),
                          size = 3,
                          segment.color = "gray80",
                          max.overlaps = 100,
                          inherit.aes = FALSE,
                          fill = "white",
                          alpha = 0.9) +
          
          labs(
            title = "PCA of DEGs (10 most influential genes)",
            subtitle = paste0("PERMANOVA: R² = ", r2,
                              ", p = ", pval_permanova,
                              " | PERMDISP p = ", pval_permdisp),
            x = paste0("PC1 (", round(summary(pca_result)$importance[2,1] * 100, 1), "%)"),
            y = paste0("PC2 (", round(summary(pca_result)$importance[2,2] * 100, 1), "%)")
          ) +
          scale_color_manual(values = c("Control" = "#E69F00", "Case" = "#56B4E9")) +
          theme_minimal() +
          theme(
            plot.title = element_text(face = "bold", size = 10),
            plot.subtitle = element_text(size = 10),
            legend.text = element_text(size = 10),
            legend.title = element_text(size = 10),
            axis.title = element_text(size = 10)
          )
        
        print(pca_gene)        
        
saveRDS(pca_gene, file = "pca_genes.rds")

```

Generating a volcano plot to visualize differential gene expression in transcriptomic data

```{r}
#| warning: false
#Volcano Plot
#create the volcano plot
options(ggrepel.max.overlaps = Inf)

vplot_gene <- 
  topTable(fit.limma, n = Inf) %>% 
  as.data.frame() %>% 
  rownames_to_column("Gene") %>%
  mutate(Regulation = case_when(
    adj.P.Val < 0.10 & logFC > 0.2 ~ "Upregulated",
    adj.P.Val < 0.10 & logFC < -0.2 ~ "Downregulated",
    TRUE ~ "Not Significant"
  )) %>%
  ggplot() +
  geom_point(aes(x = logFC, y = -log10(P.Value), fill = Regulation), 
             pch = 21, size = 2) +
  scale_fill_manual(values = c("Upregulated" = "#E69F00",  
                               "Downregulated" = "#56B4E9",  
                               "Not Significant" = "grey80")) +
  geom_label_repel(
  aes(
    x = logFC,
    y = -log10(P.Value),
    label = ifelse((adj.P.Val < 0.10 & (logFC > 0.585 | logFC < -0.585)), 
                   as.character(Gene), "")
  ),
  size = 3,
  alpha = 0.8,
  box.padding = 0.5,
  point.padding = 0.3,
  force = 2,
  max.overlaps = 200
)+
  geom_hline(yintercept = 2, linetype = "dashed", alpha = 0.3) +  
  geom_vline(xintercept = 0.0, linetype = "dashed", alpha = 0.3) +
  scale_x_continuous(expand = expansion(mult = 0.009)) +  # 10% extra space
  scale_y_continuous(expand = expansion(mult = 0.009)) +  # 10% extra space
  labs(
    x = "Log2 (Fold Change)", 
    y = "-Log10 (P value)", 
    title = "Volcano Plot DEGs"
  ) +
  theme_classic() +
  theme(
    plot.title = element_text(face = "bold", size = 10),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    axis.title = element_text(size = 10)
  )

print(vplot_gene)

saveRDS(vplot_gene, file = "volcanoplot_genes.rds")

```

Converting Gene Names to Entrez ID Format for NetworkAnalyst

```{r}
#| warning: false
#CHANGING THE SIGNIFICANT NAMES TO ENTREZ ID
library(org.Hs.eg.db)
library(AnnotationDbi)

res <- res %>%
  filter(adj.P.Val<0.10)

# Extract unique gene symbols from your data
genes <- unique(res$Gene)

# Map symbols to Entrez IDs
mapping <- AnnotationDbi::select(org.Hs.eg.db,
                                 keys = genes,
                                 columns = c("ENTREZID"),
                                 keytype = "SYMBOL")

# View mapping
head(mapping)

# Merge with original data frame by gene symbol
res_mapped <- merge(res, mapping, by.x = "Gene", by.y = "SYMBOL", all.x = TRUE)

# Check results
head(res_mapped)

write.csv(res_mapped, "SignificantGenes.csv", row.names = FALSE)
```

Compiling a table of annotations for genes found to be significant

```{r}
#| warning: false
library(readxl)
PanCancer <- read_excel("PanCancer.xlsx")
head(PanCancer)
library(readr)
SignificantGenes <- read_csv("SignificantGenes.csv")
head(SignificantGenes)

AnnotatedGenes <- left_join(SignificantGenes, PanCancer)
head(AnnotatedGenes)

AnnotatedGenes %>% 
  dplyr::select(Gene, FullName, P.Value, adj.P.Val) %>% 
  arrange(adj.P.Val) %>% 
  DT::datatable()

write.csv(AnnotatedGenes, "AnnotatedGenes.csv", row.names = FALSE)
```

### Metabolomics

Importing the dataset of 24 annotated metabolites found to be significantly different between Long COVID cases and controls (t-test, p \< 0.05) at the post-infection timepoint.

```{r}
library(tidyverse)
#| warning: false
#Importing the data
library(readr)
Significant_all_biomarkers <- read_csv("Significant_all_biomarkers.csv")

Significant_all <- Significant_all_biomarkers

#Mutating all character variables to factors
Significant_all <-
  Significant_all %>%
  mutate_if(is.character,as.factor)
str(Significant_all)

#Checking that the first level of Phenotype variable is Control
Significant_all$Phenotype
levels(Significant_all$Phenotype)
Significant_all$Phenotype <-  factor(Significant_all$Phenotype, levels =  c("Control", "Case"))
levels(Significant_all$Phenotype)

#Checking that the first level of Time variable is 0 meaning pre-infection
Significant_all$Time <- as.factor(Significant_all$Time)
levels(Significant_all$Time)
```

Log10 transformation and imputation of zero values. Zero values were imputed prior to log10 transformation using the approach from MetaboAnalyst, which replaces zeros with one-fifth of the smallest value of the respective feature.

```{r}
#| warning: false

# Ensure df is a dataframe
Significant_all <- as.data.frame(Significant_all)

# Identify metabolite columns (numeric variables, excluding 'Age')
metabolite_cols <- setdiff(names(Significant_all)[sapply(Significant_all, is.numeric)], "Age")

# Function to replace zeros with 1/5 of the smallest nonzero value
impute_zeros <- function(x) {
  min_value <- min(x[x > 0], na.rm = TRUE)  # Find the smallest nonzero value
  x[x == 0] <- min_value / 5  # Replace zeros
  return(x)
}

# Apply the function to numeric metabolite columns
Significant_all_imputed <- Significant_all %>%
  mutate(across(all_of(metabolite_cols), ~ impute_zeros(.)))

# View the first few rows
head(Significant_all_imputed)

#LOG TRANSFORMATION
# Identify metabolite columns (excluding categorical variables)
metabolite_cols <- names(Significant_all_imputed)[sapply(Significant_all_imputed, is.numeric)]

# Apply log10 transformation
Significant_all_imputed_log10 <- Significant_all_imputed %>%
  mutate(across(all_of(metabolite_cols), log10))

# View transformed dataset
head(Significant_all_imputed_log10)
View(Significant_all_imputed_log10)
levels(Significant_all_imputed_log10$Phenotype)
levels(Significant_all_imputed_log10$Time)
str(Significant_all_imputed_log10)
```

T-test at Pre-infection Timepoint for Metabolomics
```{r}
#| warning: false
library(dplyr)
library(purrr)
library(tibble)

# Get metabolite columns (exclude metadata)
metabolite_cols <- colnames(Significant_all_imputed_log10)[
  !(colnames(Significant_all_imputed_log10) %in% 
      c("Sample","Phenotype","Time","Subject","Age","SexBirth","Race",
        "DiagHyper","DiagDiabetes","DiagAsthma","DiagChronicMed18"))
]

# Filter baseline only
baseline_df <- Significant_all_imputed_log10 %>%
  filter(Time == "0")

# Run t-tests for Control vs Case
t_test_results <- map_df(metabolite_cols, function(met) {
  df <- baseline_df %>% 
    dplyr::select(Phenotype, !!sym(met))
  
  if(length(unique(df$Phenotype)) == 2) {
    t_res <- t.test(df[[met]] ~ df$Phenotype)
    tibble(
      Metabolite = met,
      mean_Control = mean(df[[met]][df$Phenotype == "Control"], na.rm = TRUE),
      mean_Case    = mean(df[[met]][df$Phenotype == "Case"], na.rm = TRUE),
      estimate     = diff(rev(t_res$estimate)), # Case - Control
      p_value      = t_res$p.value
    )
  } else {
    tibble(Metabolite = met, mean_Control = NA, mean_Case = NA,
           estimate = NA, p_value = NA)
  }
})

# Add only FDR correction
t_test_results <- t_test_results %>%
  mutate(
    p_adj_FDR = p.adjust(p_value, method = "fdr")
  )

view(t_test_results)
# Save results
write.csv(t_test_results, file = "Metabolites_ttest_T0.csv", row.names = FALSE)

```

T-test at post-infection timepoint for Metabolomics
```{r}
#| warning: false
library(dplyr)
library(purrr)
library(tibble)

# Use the same metabolite column list
metabolite_cols <- colnames(Significant_all_imputed_log10)[
  !(colnames(Significant_all_imputed_log10) %in% 
      c("Sample","Phenotype","Time","Subject","Age","SexBirth","Race",
        "DiagHyper","DiagDiabetes","DiagAsthma","DiagChronicMed18"))
]

# Filter post-infection only (Time == "1")
post_df <- Significant_all_imputed_log10 %>%
  filter(Time == "1")

# Run t-tests for Control vs Case at post-infection
t_test_results_post <- map_df(metabolite_cols, function(met) {
  df <- post_df %>% 
    dplyr::select(Phenotype, !!sym(met))
  
  if(length(unique(df$Phenotype)) == 2) {
    t_res <- t.test(df[[met]] ~ df$Phenotype)
    tibble(
      Metabolite = met,
      mean_Control = mean(df[[met]][df$Phenotype == "Control"], na.rm = TRUE),
      mean_Case    = mean(df[[met]][df$Phenotype == "Case"], na.rm = TRUE),
      estimate     = diff(rev(t_res$estimate)), # Case - Control
      p_value      = t_res$p.value
    )
  } else {
    tibble(Metabolite = met, mean_Control = NA, mean_Case = NA,
           estimate = NA, p_value = NA)
  }
})

# Add only FDR correction
t_test_results_post <- t_test_results_post %>%
  mutate(
    p_adj_FDR = p.adjust(p_value, method = "fdr")
  )
view(t_test_results_post)
# Save results
write.csv(t_test_results, file = "Metabolites_ttest_T1.csv", row.names = FALSE)

```

Paired t-tests to asses variation in metabolites from pre-infection to post-infection timepoints in cases and in controls
```{r}
#| warning: false
library(dplyr)
library(purrr)
library(tidyr)
library(tibble)

# Metabolite columns
metabolite_cols <- colnames(Significant_all_imputed_log10)[
  !(colnames(Significant_all_imputed_log10) %in% 
      c("Sample","Phenotype","Time","Subject","Age","SexBirth","Race",
        "DiagHyper","DiagDiabetes","DiagAsthma","DiagChronicMed18"))
]

# Run paired t-tests per group (Control vs Case separately)
paired_results <- map_df(metabolite_cols, function(met) {
  Significant_all_imputed_log10 %>%
    group_by(Phenotype) %>%
    group_modify(~{
      # Reshape so each subject has one row with pre and post
      df <- .x %>%
        dplyr::select(Subject, Time, !!sym(met)) %>%
        pivot_wider(names_from = Time, values_from = !!sym(met))
      
      # Keep only subjects with both timepoints
      df <- df %>% filter(!is.na(`0`), !is.na(`1`))
      
      if(nrow(df) > 1) {
        t_res <- t.test(df$`0`, df$`1`, paired = TRUE)
        tibble(
          Metabolite = met,
          Phenotype = unique(.x$Phenotype),
          mean_pre  = mean(df$`0`),
          mean_post = mean(df$`1`),
          estimate  = t_res$estimate,  # mean difference (pre - post)
          p_value   = t_res$p.value
        )
      } else {
        tibble(Metabolite = met,
               Phenotype = unique(.x$Phenotype),
               mean_pre = NA,
               mean_post = NA,
               estimate = NA,
               p_value = NA)
      }
    })
})

# Add FDR correction
paired_results <- paired_results %>%
  group_by(Phenotype) %>%
  mutate(
    p_adj_FDR = p.adjust(p_value, method = "fdr")
  ) %>%
  ungroup()

view(paired_results)
# Save results
write.csv(paired_results, file = "Metabolites_paired_ttest.csv", row.names = FALSE)

```

Interaction Phenotype x Timepoint by Linear Mixed Models in Metabolomics

```{r}
#| warning: false
library(lme4)
library(lmerTest)
library(dplyr)
library(purrr)
library(tibble)

metabolite_cols <- colnames(Significant_all_imputed_log10)[
  !(colnames(Significant_all_imputed_log10) %in% 
      c("Sample","Phenotype","Time","Subject","Age","SexBirth","Race",
        "DiagHyper","DiagDiabetes","DiagAsthma","DiagChronicMed18"))
]

interaction_results <- map_df(metabolite_cols, function(met) {
  
  df <- Significant_all_imputed_log10 %>%
    dplyr::select(Subject, Time, Phenotype, !!sym(met)) %>%
    filter(!is.na(!!sym(met)))
  
  # Make sure factors are correct
  df$Time <- factor(df$Time)
  df$Phenotype <- factor(df$Phenotype)
  
  if(nrow(df) > 1) {
    # Build formula dynamically
    formula_str <- paste0("`", met, "` ~ Time * Phenotype + (1 | Subject)")
    model <- lmer(as.formula(formula_str), data = df)
    sum_model <- summary(model)
    
    # Extract interaction term safely
    inter_name <- "Time1:PhenotypeCase"
    if(inter_name %in% rownames(sum_model$coefficients)) {
      inter_row <- sum_model$coefficients[inter_name, ]
      tibble(
        Metabolite = met,
        estimate_interaction = inter_row["Estimate"],
        p_value_interaction = inter_row["Pr(>|t|)"]
      )
    } else {
      tibble(Metabolite = met, estimate_interaction = NA, p_value_interaction = NA)
    }
  } else {
    tibble(Metabolite = met, estimate_interaction = NA, p_value_interaction = NA)
  }
})

# Add FDR
interaction_results <- interaction_results %>%
  mutate(p_adj_FDR_interaction = p.adjust(p_value_interaction, method = "fdr"))

View(interaction_results)

# Save results
write.csv(interaction_results, file = "Metabolites_LMM_interaction.csv", row.names = FALSE)

```

Volcano Plot for metabolites at post-infection timepoint
```{r}
view(Significant_all_imputed)
str(Significant_all_imputed)

#LOG 2 TRANSFORMATION
# Identify metabolite columns (excluding categorical variables)
metabolite_cols <- names(Significant_all_imputed)[sapply(Significant_all_imputed, is.numeric)]

# Apply log2 transformation
Significant_all_imputed_log2 <- Significant_all_imputed %>%
  mutate(across(all_of(metabolite_cols), log2))

# View transformed dataset
head(Significant_all_imputed_log2)

levels(Significant_all_imputed$Phenotype)
levels(Significant_all_imputed$Time)

library(limma)
library(edgeR)
library(ggrepel)

#Filtering Only Post Infection Timepoint
Significant_all_imputed_Post_log2 <- Significant_all_imputed_log2 %>%
  filter(Time=="1")
view(Significant_all_imputed_Post_log2)

#creating counts_data with variables: SampleID and Metabolite's counts
counts_data <- Significant_all_imputed_Post_log2[,c(1,12:34)]
head(counts_data)

#transpose this data to create the counts data
counts_new <- data.frame(t(counts_data[-1]))
colnames(counts_new) <- counts_data[, 1]

#now get the column data
column_data <- Significant_all_imputed_Post_log2[,c(1:4)]

#changing the order of the levels to have controls first and then cases
column_data$Phenotype
levels(column_data$Phenotype)

#check whether all column names in counts data also exist in rownames in column data
all(colnames(counts_new) %in% (column_data$Sample))

#check whether the rows and columns are in the same order (i.e., the subject IDs)
all(colnames(counts_new) == column_data$Sample)

#for limma, create a design matrix
design <- model.matrix(~Phenotype, data=column_data)

# Fit the linear model
fit <- lmFit(counts_new, design)
fit.limma <- eBayes(fit)

#create the volcano plot
options(ggrepel.max.overlaps = Inf)

VolcanoPlot_LCvsControl <- 
  topTable(fit.limma, n = Inf) %>% 
  as.data.frame() %>% 
  rownames_to_column("Metabolite") %>%
  mutate(Regulation = case_when(
    adj.P.Val < 0.05 & logFC > 0.2 ~ "Upregulated",
    adj.P.Val < 0.05 & logFC < -0.2 ~ "Downregulated",
    TRUE ~ "Not Significant"
  )) %>%
  ggplot() +
  geom_point(aes(x = logFC, y = -log10(P.Value), fill = Regulation), pch = 21, size = 3) +
  scale_fill_manual(values = c("Upregulated" = "#E69F00",  # red
                               "Downregulated" = "#56B4E9",  # blue
                               "Not Significant" = "grey80")) +
  geom_label_repel(
  aes(
    x = logFC,
    y = -log10(P.Value),
    label = ifelse((adj.P.Val < 0.05 & (logFC > 0.565 | logFC < 0.565)), 
                   as.character(Metabolite), "")
  ),
  size = 3,
  alpha = 0.8,
  box.padding = 0.5,
  point.padding = 0.3,
  force = 2,
  max.overlaps = 200
) +
  geom_hline(yintercept = 1.3, linetype = "dashed", alpha = 0.3) +  # ~P = 0.05
  geom_vline(xintercept = 0.0, linetype = "dashed", alpha = 0.3) +
  scale_x_continuous(expand = expansion(mult = 0.009)) +  # 10% extra space
  scale_y_continuous(expand = expansion(mult = 0.009)) +  # 10% extra space
  labs(
    x = "Log2 (Fold Change)", 
    y = "-Log10 (P value)", 
    title = "Volcano Plot of Metabolites"
  ) +
  theme_classic() +
  theme(
    plot.title = element_text(face = "bold", size = 10),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    axis.title = element_text(size = 10)
  )

# Display the plot
print(VolcanoPlot_LCvsControl)

saveRDS(VolcanoPlot_LCvsControl, file = "volcanoplot_metabolites.rds")

```

Following FDR correction, oxoglutarate was the only metabolite exhibiting a significant interaction between Long COVID status and the pre- versus post-infection timepoints.

```{r}
#| warning: false
#PLOT OXOGLUTARATE
str(Significant_all_imputed_log10)

# 1. Ensure factor levels for Time
Significant_all_imputed_log10$Time <- factor(Significant_all_imputed_log10$Time,
                             levels = c("0", "1"),
                             labels = c("Pre", "Post"))

combined_data <- Significant_all_imputed_log10

#1. Run paired t-tests manually per group
# Filter Pre and Post separately
pre_control  <- combined_data[combined_data$Phenotype == "Control" & combined_data$Time == "Pre", ]
post_control <- combined_data[combined_data$Phenotype == "Control" & combined_data$Time == "Post", ]

pre_case  <- combined_data[combined_data$Phenotype == "Case" & combined_data$Time == "Pre", ]
post_case <- combined_data[combined_data$Phenotype == "Case" & combined_data$Time == "Post", ]

# Ensure matching Subject order
pre_control <- pre_control[order(pre_control$Subject), ]
post_control <- post_control[order(post_control$Subject), ]

pre_case <- pre_case[order(pre_case$Subject), ]
post_case <- post_case[order(post_case$Subject), ]

# Paired t-tests
t_control <- t.test(pre_control$OXOGLUTARATE, post_control$OXOGLUTARATE, paired = TRUE)
t_case <- t.test(pre_case$OXOGLUTARATE, post_case$OXOGLUTARATE, paired = TRUE)

# Print results
cat("Control p-value:", t_control$p.value, "\n")
cat("Case p-value:", t_case$p.value, "\n")

#2. Add significance lines and stars manually to the plot
#Let’s assume the p-values were:
p_control <- t_control$p.value
p_case <- t_case$p.value

#Final Plot with Manual Annotations
library(ggplot2)

# Set Y positions for annotation lines
y_control <- max(pre_control$OXOGLUTARATE, post_control$OXOGLUTARATE, na.rm = TRUE) * 1.05
y_case <- max(pre_case$OXOGLUTARATE, post_case$OXOGLUTARATE, na.rm = TRUE) * 1.05

OXOGLUTARATE_ALL <- ggplot(combined_data, aes(x = Time, y = OXOGLUTARATE, fill = Phenotype)) +
  geom_violin(trim = FALSE, color = NA) +
  geom_line(aes(group = Subject), color = "#999999", size = 0.5) +
  geom_point(color = "#999999", size = 1) +
  facet_wrap(~Phenotype) +
  scale_fill_manual(values = c("Control" = "#E69F00", "Case" = "#56B4E9")) +
  labs(
    title = "Oxoglutarate Paired T-test",
    y = "Metabolite level"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
    axis.title.x = element_blank(),
    axis.text.x = element_text(size = 10),
    axis.title.y = element_text(size = 10),
    strip.text = element_blank(),
    legend.title = element_text(size = 10),  # title (e.g., "Phenotype")
  legend.text = element_text(size = 10)    # labels (e.g., "Case", "Control")
  ) +
  # Manual significance lines and stars
  geom_segment(data = data.frame(Phenotype = "Control"),
               aes(x = 1, xend = 2, y = y_control, yend = y_control),
               inherit.aes = FALSE) +
  geom_text(data = data.frame(Phenotype = "Control"),
            aes(x = 1.5, y = y_control + 0.02, label = ifelse(p_control < 0.05, "*", "ns")),
            size = 6,
            inherit.aes = FALSE) +
  geom_segment(data = data.frame(Phenotype = "Case"),
               aes(x = 1, xend = 2, y = y_case, yend = y_case),
               inherit.aes = FALSE) +
  geom_text(data = data.frame(Phenotype = "Case"),
            aes(x = 1.5, y = y_case + 0.02, label = ifelse(p_case < 0.001, "***", 
                                                           ifelse(p_case < 0.01, "**", 
                                                                  ifelse(p_case < 0.05, "*", "ns")))),
            size = 6,
            inherit.aes = FALSE)
print(OXOGLUTARATE_ALL)

library(dplyr)

# Calculate mean and standard error per group/time
summary_data <- combined_data %>%
  group_by(Phenotype, Time) %>%
  summarise(
    mean_OXO = mean(OXOGLUTARATE, na.rm = TRUE),
    se_OXO   = sd(OXOGLUTARATE, na.rm = TRUE)/sqrt(n()),
    .groups = "drop"
  )

print(summary_data)

# Add error bars to your existing violin + points + lines plot
OXOGLUTARATE_ALL <- OXOGLUTARATE_ALL +
  geom_errorbar(
    data = summary_data,
    aes(x = Time, ymin = mean_OXO - se_OXO, ymax = mean_OXO + se_OXO),
    width = 0.2,
    color = "black",
    position = position_dodge(width = 0.75),
    inherit.aes = FALSE
  ) +
  geom_point(
    data = summary_data,
    aes(x = Time, y = mean_OXO),
    color = "black",
    size = 3,
    position = position_dodge(width = 0.75),
    inherit.aes = FALSE
  )

print(OXOGLUTARATE_ALL)

saveRDS(OXOGLUTARATE_ALL, file =  "oxo_plot.rds")
```

Performing PCA and PERMANOVA to analyze metabolomic data

```{r}
#| warning: false
library(tidyverse)
library(ggrepel)
library(vegan)
library(RColorBrewer)
library(ggpubr)

# 1️⃣ Prepare metabolite matrix and metadata
metabolite_matrix <- Significant_all_imputed_log10[, 12:34]
phenotype <- Significant_all_imputed_log10$Phenotype

# 2️⃣ PCA
pca_result <- prcomp(metabolite_matrix, scale. = TRUE)
pca_scores <- as.data.frame(pca_result$x)
pca_scores$Phenotype <- phenotype

# 3️⃣ PERMANOVA
dist_matrix <- dist(metabolite_matrix, method = "euclidean")
permanova_result <- adonis2(dist_matrix ~ Phenotype, data = Significant_all_imputed_log10, permutations = 999)
r2 <- round(permanova_result$R2[1], 3)
pval_permanova <- format.pval(permanova_result$`Pr(>F)`[1], digits = 3, eps = 0.001)

# 4️⃣ PERMDISP
dispersion <- betadisper(dist_matrix, phenotype)
permutest_disp <- permutest(dispersion)
pval_permdisp <- format.pval(permutest_disp$tab[1, "Pr(>F)"], digits = 3, eps = 0.001)

# 5️⃣ Top 10 metabolite loadings
loadings <- as.data.frame(pca_result$rotation)
loadings$Metabolite <- rownames(loadings)

# Ensure numeric
loadings$PC1 <- as.numeric(loadings$PC1)
loadings$PC2 <- as.numeric(loadings$PC2)

# Contribution for ranking
loadings$contribution <- sqrt(loadings$PC1^2 + loadings$PC2^2)

# Select top 10
top_loadings <- loadings %>%
  arrange(desc(contribution)) %>%
  slice_head(n = 10) %>%
  mutate(
    PC1 = PC1 * 5,   # scale arrows for visibility
    PC2 = PC2 * 5
  )
#Scaling the loadings
top_loadings_scaled <- top_loadings %>%
  mutate(
    PC1 = PC1 * 1.2,   
    PC2 = PC2 * 1.2    
  )

#PCA plot
pca_plot <- ggplot(pca_scores, aes(x = PC1, y = PC2, color = Phenotype)) +
  geom_point(size = 1, alpha = 0.8) +
  ggpubr::stat_stars(aes(group = Phenotype), linetype = 2, size = 1) +  
  
  # Loading vectors (scaled)
  geom_segment(data = top_loadings_scaled,
               aes(x = 0, y = 0, xend = PC1, yend = PC2),
               arrow = arrow(length = unit(0.2, "cm")),
               color = "gray50", inherit.aes = FALSE) +
  
  # Loading labels (scaled)
  geom_label_repel(
    data = top_loadings_scaled,
    aes(x = PC1, y = PC2, label = Metabolite),
    size = 3,
    segment.color = "gray80",
    max.overlaps = 100,
    inherit.aes = FALSE,
    fill = "white",
    alpha = 0.8
  ) +
  
  labs(
    title = "PCA of Metabolites (10 most influential metabolites)",
    subtitle = paste0("PERMANOVA: R² = ", r2,
                      ", p = ", pval_permanova,
                      " | PERMDISP p = ", pval_permdisp),
    x = paste0("PC1 (", round(summary(pca_result)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca_result)$importance[2,2] * 100, 1), "%)")
  ) +
  scale_color_manual(values = c("Control" = "#E69F00", "Case" = "#56B4E9")) +
  scale_y_continuous(limits = c(-7.5, 6)) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 10),
    plot.subtitle = element_text(size = 10),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    axis.title = element_text(size = 10)
  )

print(pca_plot)

# Save
saveRDS(pca_plot, file = "pca_metabolites_final_stars.rds")

```

**Integrating Transcriptomics and Metabolomics Plots into a Single Figure**

```{r}
#| warning: false
library(ggplot2)
library(patchwork)

# Load all plots
oxo_plot <- readRDS("oxo_plot.rds")
vplot_metabolite <- readRDS("volcanoplot_metabolites.rds")
pca_met <- readRDS("pca_metabolites_final_stars.rds")
vplot_gene <- readRDS("volcanoplot_genes.rds")
pca_gene <- readRDS("pca_genes.rds")

# Combine into 2x2 grid
combined_plot <- (vplot_gene + pca_gene)/ (oxo_plot + pca_met) + plot_annotation(tag_levels = "A") 

combined_plot

library(patchwork)

# Remove legends from vplot_gene and pca_gene
vplot_gene_clean <- vplot_gene + theme(legend.position = "none")
pca_gene_clean   <- pca_gene + theme(legend.position = "none")
pca_met_clean   <- pca_met + theme(legend.position = "none")

# Combine plots in 2x2 grid
combined_plot <- (vplot_gene + pca_gene_clean) / 
                 (oxo_plot + pca_met_clean) + 
                 plot_annotation(tag_levels = "A")

combined_plot

ggsave("Metabolomics_Transcriptomics.pdf", 
       combined_plot, 
       width = 12, height = 10, units = "in")

ggsave(
  filename = "combined_plot.png",   # file path
  plot = combined_plot,                      
  width = 12,                                # width in inches
  height = 10,                                # height in inches
  dpi = 600                                  # resolution 
)

# Save as TIFF (600 dpi)
ggsave(
  filename = "combined_plot.tiff",
  plot = combined_plot,
  width = 12, height = 10, units = "in", dpi = 600,
  compression = "lzw"   #to reduce size
)
```

### **Network Analysis**

Significant metabolites were mapped to their corresponding enzyme genes in Metabridge using MetaCyc. Gene names were then converted to Entrez IDs for upload to NetworkAnalyst.

```{r}
#| warning: false
library(biomaRt)

# Connect to Ensembl BioMart (human genes)
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Your gene list
genes <- c("ALDH3A2","PLA/AT3","PLA2G1B","PLA2G4A","CEPT1","LPCAT4","CDA","TK1",
           "TK2","TYMP","UPP1","CAD","PPAT","GLUL","PFAS","NADSYN1","CTPS1","CTPS2",
           "GFPT1","CAD","CTPS1","CTPS2","GLS","SLC3A2","SLC7A6","UPB1","DPYS","TPH1",
           "TPH2","IDO1","TDO2","DDC","SLC3A2","SLC7A5","SLC7A8","PNP","XDH","HPRT1",
           "PNP","SDS","SDSL","SDS","SDSL","ABAT","BBOX1","D2HGDH","ABAT","DLD","DLST",
           "OGDH","RIOX1","RIOX2","DLD","DLST","OGDH","SUGCT","AADAT","CCBL2","AADAT",
           "CCBL2","ABAT","PSAT1","TYW5","GOT2","TMLHE","PSAT1","PHYH","TET1","TET1",
           "TET1","KDM6A","KDM6B","KDM6A","KDM6B","KDM4A","KDM4B","KDM4C","RIOX1","KDM4A",
           "KDM4B","KDM4C","RIOX1","KDM2B","KDM5A","KDM5B","KDM5C","KDM5D","RIOX1","KDM5A",
           "KDM5B","KDM5C","KDM5D","RIOX1","KDM4A","KDM4B","KDM4C","KDM4A","KDM4B","KDM4C",
           "RIOX2","KDM6A","KDM6B","KDM2A","KDM2B","KDM2A","KDM2B","KDM4A","KDM4B","KDM4C",
           "RIOX1","HR","KDM3A","KDM3B","HR","KDM3A","KDM3B","KDM4A","KDM4B","KDM4C","KDM7B",
           "KDM2A","KDM2B","HR","KDM3A","KDM3B","KDM7B","KDM5A","KDM5B","KDM5C","KDM5D",
           "RIOX1","KDM5A","KDM5B","KDM5C","KDM5D","RIOX1","KDM7B","HIF1AN","EGLN2","PLOD1",
           "P4HA1","P4HB","CRTAP","P3H1","PPIB","KDM3A","KDM4A","KDM5C","KDM3A","KDM4A",
           "KDM5C","KDM3A","KDM4A","KDM5C","KDM6B","KDM3A","KDM4A","KDM5C","KDM6B","KDM3A",
           "KDM4A","KDM5C","KDM6B","JMJD5","IDH3A","IDH3B","IDH3G","IDH1","IDH2","DAO",
           "AADAT","GPT","GPT2","GOT2","CISD1","GLUD1","GLUD2","GLUD1","GLUD2","GLUD1",
           "GLUD2","AADAT","CCBL2","GOT2","AADAT","CCBL2","GOT2","OAT","AASS","TAT","IDH1",
           "IDH2","PHYH","ASPG","ASRGL1","DHTKD1","AADAT")

# Query BioMart to map Gene Symbol -> Entrez ID
mapping <- getBM(
  attributes = c("hgnc_symbol", "entrezgene_id"),
  filters = "hgnc_symbol",
  values = genes,
  mart = mart
)

# Remove duplicates and NAs
mapping_unique <- mapping %>%
  dplyr::filter(!is.na(entrezgene_id)) %>%
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)

# Save to CSV
write.csv(mapping_unique, "Metabolite_entrezID.csv", row.names = FALSE)

```

Performing network analysis on the significant genes/metabolites

```{r}
#| warning: false
# Load packages
library(igraph)
library(tidyverse)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(ggraph)
library(tidygraph)

library(igraph)

# Load network from NetworkAnalyst (GraphML)
g_raw <- read_graph("network_1.graphml", format = "graphml")
# Step 1: Get raw edges and nodes
edges_df <- igraph::as_data_frame(g_raw, what = "edges")
nodes_df <- igraph::as_data_frame(g_raw, what = "vertices")

# Preview structure
head(edges_df)
head(nodes_df)

# Step 2: Map Entrez IDs (in edges) to Gene Symbols using org.Hs.eg.db
all_ids <- unique(c(edges_df$from, edges_df$to))

# Ensure IDs are characters
all_ids <- as.character(all_ids)

# Map Entrez to SYMBOL
id_map <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = all_ids,
  columns = "SYMBOL",
  keytype = "ENTREZID"
) %>% distinct()

# Step 3: Add gene symbols to edge list
edges_labeled <- edges_df %>%
  left_join(id_map, by = c("from" = "ENTREZID")) %>%
  rename(from_symbol = SYMBOL) %>%
  left_join(id_map, by = c("to" = "ENTREZID")) %>%
  rename(to_symbol = SYMBOL) %>%
  filter(!is.na(from_symbol) & !is.na(to_symbol)) %>%
  select(from_symbol, to_symbol)

# Step 4: Build labeled graph
g <- graph_from_data_frame(edges_labeled, directed = FALSE)

# Convert to tidygraph
g_tbl <- as_tbl_graph(g)

# Step 5: Highlight genes from metabolomics dataset
met_genes <- c(
  "ALDH3A2","PLA/AT3","PLA2G1B","PLA2G4A","CEPT1","LPCAT4","CDA","TK1",
           "TK2","TYMP","UPP1","CAD","PPAT","GLUL","PFAS","NADSYN1","CTPS1","CTPS2",
           "GFPT1","CAD","CTPS1","CTPS2","GLS","SLC3A2","SLC7A6","UPB1","DPYS","TPH1",
           "TPH2","IDO1","TDO2","DDC","SLC3A2","SLC7A5","SLC7A8","PNP","XDH","HPRT1",
           "PNP","SDS","SDSL","SDS","SDSL","ABAT","BBOX1","D2HGDH","ABAT","DLD","DLST",
           "OGDH","RIOX1","RIOX2","DLD","DLST","OGDH","SUGCT","AADAT","CCBL2","AADAT",
           "CCBL2","ABAT","PSAT1","TYW5","GOT2","TMLHE","PSAT1","PHYH","TET1","TET1",
           "TET1","KDM6A","KDM6B","KDM6A","KDM6B","KDM4A","KDM4B","KDM4C","RIOX1","KDM4A",
           "KDM4B","KDM4C","RIOX1","KDM2B","KDM5A","KDM5B","KDM5C","KDM5D","RIOX1","KDM5A",
           "KDM5B","KDM5C","KDM5D","RIOX1","KDM4A","KDM4B","KDM4C","KDM4A","KDM4B","KDM4C",
           "RIOX2","KDM6A","KDM6B","KDM2A","KDM2B","KDM2A","KDM2B","KDM4A","KDM4B","KDM4C",
           "RIOX1","HR","KDM3A","KDM3B","HR","KDM3A","KDM3B","KDM4A","KDM4B","KDM4C","KDM7B",
           "KDM2A","KDM2B","HR","KDM3A","KDM3B","KDM7B","KDM5A","KDM5B","KDM5C","KDM5D",
           "RIOX1","KDM5A","KDM5B","KDM5C","KDM5D","RIOX1","KDM7B","HIF1AN","EGLN2","PLOD1",
           "P4HA1","P4HB","CRTAP","P3H1","PPIB","KDM3A","KDM4A","KDM5C","KDM3A","KDM4A",
           "KDM5C","KDM3A","KDM4A","KDM5C","KDM6B","KDM3A","KDM4A","KDM5C","KDM6B","KDM3A",
           "KDM4A","KDM5C","KDM6B","JMJD5","IDH3A","IDH3B","IDH3G","IDH1","IDH2","DAO",
           "AADAT","GPT","GPT2","GOT2","CISD1","GLUD1","GLUD2","GLUD1","GLUD2","GLUD1",
           "GLUD2","AADAT","CCBL2","GOT2","AADAT","CCBL2","GOT2","OAT","AASS","TAT","IDH1",
           "IDH2","PHYH","ASPG","ASRGL1","DHTKD1","AADAT"
) %>% unique()

# Add flag to graph
V(g_tbl)$is_metabolomics <- V(g_tbl)$name %in% met_genes

# Step 7: Plot with metabolomics highlighting
ggraph(g_tbl, layout = "fr") +
  geom_edge_link(color = "gray80", alpha = 0.6) +
  geom_node_point(aes(color = is_metabolomics), size = 5) +
  geom_node_text(aes(label = name), repel = TRUE, size = 3) +
  scale_color_manual(
    values = c("TRUE" = "#E69F00", "FALSE" = "#8DA0CB"),
    labels = c("TRUE" = "Metabolomics", "FALSE" = "Transcriptomics"),
    name = NULL
  ) +
  theme_void() +
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 12)
  )

```

Performing network analysis and identifying hub nodes

```{r}
#| warning: false
# Step 8: Identify most connected (high-degree) nodes
library(dplyr)

# Step 8: Identify most connected (high-degree) nodes — corrected
node_degrees <- g_tbl %>%
  mutate(degree = centrality_degree()) %>%  # compute degree within tidygraph
  as_tibble() %>%                           # convert to tibble afterward
  arrange(desc(degree))                     # sort by descending degree

# View top 10 nodes
top_nodes <- node_degrees %>% slice_max(degree, n = 10)

# Print top nodes with degree and metabolomics flag
print(top_nodes %>% dplyr::select(name, degree, is_metabolomics))

# ---- Step 7: Convert to tidygraph & add attributes ----
g_tbl <- as_tbl_graph(g) %>%
  mutate(
    degree = centrality_degree(),
    is_metabolomics = name %in% met_genes
  )

# ---- Step 8: Plot ----
network <- ggraph(g_tbl, layout = "fr") +
  geom_edge_link(color = "gray80", alpha = 0.6) +
  geom_node_point(aes(size = degree, color = is_metabolomics)) +
  geom_node_text(aes(label = name), repel = TRUE, size = 3) +
  scale_color_manual(
    values = c("TRUE" = "#E69F00", "FALSE" = "#56B4E9"),
    labels = c("TRUE" = "Metabolomics", "FALSE" = "Transcriptomics"),
    name = NULL
  ) +
  scale_size_continuous(
    name = "Node Degree",
    range = c(2, 10)
  ) +
  guides(
    color = guide_legend(override.aes = list(size = 6))
  ) +
  labs(
        title = "Network Analysis"
  ) +
   theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 10,hjust = 0.5),
    legend.position = "bottom",
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10)
  )

print(network)

saveRDS(network, file = "Network.rds")
```

Plotting KEGG Pathway Enrichment Results from NetworkAnalyst

```{r}
#| warning: false
library(ggplot2)
library(readr)
library(dplyr)

# Load the file
library(readr)
networkanalyst_enrichment_1 <- read_csv("networkanalyst_enrichment_1.csv")
View(networkanalyst_enrichment_1)

# Clean and filter
enrich_df <- networkanalyst_enrichment_1 %>%
  mutate(Pathway = trimws(Pathway))

# Top 20 + 2 specific pathways that were enriched by both metabolomics and transcriptomics
top20 <- enrich_df %>% arrange(FDR) %>% slice_head(n = 17)
extra_paths <- enrich_df %>% filter(Pathway %in% c("Necroptosis", "Serotonergic synapse"))
combined_df <- bind_rows(top20, extra_paths) %>% distinct(Pathway, .keep_all = TRUE)

# Define which labels to highlight
highlight_labels <- c("Necroptosis", "Serotonergic synapse")

# Add a new column for label colors
combined_df <- combined_df %>%
  mutate(label_color = ifelse(Pathway %in% highlight_labels, "#E69F00", "black"))

# Reorder Pathway factor
combined_df <- combined_df %>%
  mutate(Pathway = factor(Pathway, levels = combined_df$Pathway[order(FDR)]))

# Plot with colored y-axis labels

network_enrichment <- ggplot(combined_df, aes(x = Pathway, y = -log10(FDR))) +
  geom_point(aes(size = Hits, color = -log10(FDR))) +
  coord_flip() +
  labs(
    x = NULL,
    y = "-log10(FDR)",
    title = "Top 20 KEGG Enriched Pathways in Network Analysis"
  ) +
  scale_color_gradient(low = "#56B4E9", high = "#E69F00") +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.1))) +
  theme_minimal(base_size = 10) +  # Set default base size to 10
  theme(
    plot.title.position = "plot",
    plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
    axis.title.y = element_text(size = 10),
    axis.title.x = element_text(size = 10),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(
      size = 10,
      color = combined_df$label_color,
      face = ifelse(combined_df$Pathway %in% highlight_labels, "bold", "plain")
    ),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10)
  )

print(network_enrichment)
saveRDS(network_enrichment,file =  "pathways_network.rds")
```

Creating a Combined Network Analysis Plot

```{r}
#| warning: false
# Load required libraries

library(ggplot2)
library(cowplot)  # for plot_grid and draw_plot_label

# Load your saved ggplot objects
network <- readRDS("Network.rds")
network_enrichment <- readRDS("pathways_network.rds")

# Combine the two plots horizontally with proper alignment
combined_plot_net <- plot_grid(
  network,
  network_enrichment,
  nrow = 1,
  align = "h",
  axis = "tb",
  rel_widths = c(1.3, 1)
)

# Overlay tags A and B above the plot panels (no overlap with titles)
tagged_plot <- ggdraw(combined_plot_net) +
  draw_plot_label(
    label = c("A", "B"),
    x = c(0.01, 0.51),  # adjust horizontal placement of A and B
    y = 0.99,           # vertical position (top of the plot)
    size = 14,
    fontface = "bold"
  )
print(tagged_plot)

# Save the final plot with tags
ggsave(
  filename = "Network_Analysis_Cowplot.pdf",
  plot = tagged_plot,
  width = 14, height = 7, units = "in"
)

ggsave(
  filename = "Network_Analysis_Cowplot.png",   # file path
  plot = tagged_plot,                      # the object you created
  width = 14,                                # width in inches
  height = 8,                                # height in inches
  dpi = 600                                  # resolution (good for publication)
)
```
